NAME
    SQL::Pico - Prebinded Raw SQL Statement Builder

SYNOPSIS
        use SQL::Pico ();
    
        $dbh    = DBI->connect(...);
        $sqlp   = SQL::Pico->new->dbh($dbh);
        $quoted = $sqlp->quote($val);             # $dbh->quote($val)
        $quoted = $sqlp->quote_identifier($key);  # $dbh->quote_identifier($key)

        $select = $sqlp->bind("SELECT * FROM ?? WHERE id = ?", $table, $id);
    
        $where  = join(" AND " => $sqlp->bind("?? = ?", %hash));
        $select = $sqlp->bind("SELECT * FROM mytbl WHERE ???", $where);

        $keys   = join(", " => $sqlp->quote_identifier(keys %hash));
        $vals   = join(", " => $sqlp->quote(values %hash));
        $insert = $sqlp->bind("INSERT INTO mytbl (???) VALUES (???)", $keys, $vals);

        $sets   = join(", " => $sqlp->bind("?? = ?", %hash));
        $update = $sqlp->bind("UPDATE mytbl SET ??? WHERE id = ?", $sets, $id);

        $in     = join(", " => v(@list));
        $delete = $sqlp->bind("DELETE mytbl WHERE id IN (???)", $in);

DESCRIPTION
    This provides a simple but safe way to build SQL statements without
    learning any other languages than Perl and SQL.

    Most of ORM modules and something SQL::Builder modules would have
    required you to understand a complex structure or dialectal DSL. This
    module provides just one new method of "bind()", which allows you to
    build raw SQL statements with placeholders, as well as "quote()" and
    "quote_identifier()" methods which are wrappers of DBI's same methods
    you already know.

METHODS
  new(PARAMETERS)
    This creates a "SQL::Pico" instance.

        $sqlp = SQL::Pico->new;

    This accepts key/value pair(s) as its initial parameters. Only "dbh"
    parameter is available at this module.

        $sqlp = SQL::Pico->new(dbh => $dbh);

  dbh(DBHANDLE)
    This is accessor to specify a "DBI" instance.

        $sqlp = SQL::Pico->new;
        $sqlp->dbh($dbh);

    The setter returns the current "SQL::Pico" instance for you to chain
    method calls.

        $quoted = SQL::Pico->new->dbh($dbh)->quote($val);

    The quoting format depends on database systems. For example, a literal
    string "Don't" would be quoted as 'Don''t', 'Don\'t', "Don't", etc. You
    need to specify a "DBI" instance to make string quoted propery.

  quote(LITERAL)
    This calls "DBI"'s "quote()" method internally.

        $quoted = $sqlp->quote($val);             # $dbh->quote($val)

    This doesn't accept literal's data type specified at its second
    argument. The other difference to original is that this accept multiple
    arguments and returns them quoted.

        @list   = $sqlp->quote(@vals);            # multiple quotes at once

  quote_identifier(IDENTIFIER)
    This calls "DBI"'s "quote_identifier()" method internally.

        $quoted = $sqlp->quote_identifier($key);  # $dbh->quote_identifier($key)

    Multiple arguments are allowed as well.

        @list   = $sqlp->quote_identifier(@keys); # multiple quotes at once

  bind(SQL, VALUES...)
    This builds a SQL statement by using placeholders with bind values.

        $sql = $sqlp->bind("SELECT * FROM ?? WHERE id = ?", $table, $id);

    Note that this returns a SQL statement built with values binded at the
    method prior to "DBI"'s <execute()> method called.

    Three types of placeholders are allowed at the first argument:

    Single character of "?" represents a placeholder for a literal which
    will be escaped by "quote()".

    Double characters of "??" represents a placeholder for an identifier
    which will be escaped by "quote_identifier()".

    Triple characters of "???" represents a placeholder for a raw SQL string
    which will not be escaped.

        $hash   = {"qux" => "foo", "quux" => "bar", "corge" => "baz"};
        @list   = $sqlp->bind("?? = ?", %$hash);
        $where  = join(" AND ", @list);
        $select = "SELECT * FROM mytable WHERE $where";

        # WHERE "qux" = 'foo' AND "quux" = 'bar' AND "corge" = 'baz'
        # Note that the order of key/value pairs varies.

    In list context, this returns a list of strings repeatedly binded with
    parameters following. It'd be useful to build "WHERE", "VALUES", "SET",
    "IN" clause, etc.

FUNCTIONS
    In addition to the OO style described above, this also supports the
    functional style and exports three shortcut functions: "v()", "k()" and
    "sql()" per default.

        use SQL::Pico;                            # functions exported
    
        $quoted = v("string");                    # quotes literal
        $quoted = k("table_name");                # quotes identifier
        $sql    = sql("SELECT * FROM ?? WHERE id = ?", $table, $id);

  v(LITERAL)
    This is a shortcut for "quote()" method which quotes a literal, e.g.
    string, number, etc.

        $quoted = v("string");                    # quotes literal
        @quoted = v("foo", "bar", "baz");         # multiple literals

  k(IDENTIFIER)
    This is a shortcut for "quote_identifier()" method which quotes an
    identifier, e.g. table name, column name, etc.

        $quoted = k("table_name");                # quotes identifier
        @quoted = k("qux", "quux", "corge");      # multiple identifiers

  sql(SQL, VALUES...)
    This is a shortcut for "bind()" method which builds a SQL statement by
    using placeholders with bind values.

        $sql  = sql("SELECT * FROM ?? WHERE id = ?", $table, $id);

  dbh(DBHANDLE)
    Use "dbh()" class method to specify the default database handle for
    those "v()", "k()" and "sql()" functions above.

        $dbh = DBI->connect(...);
        SQL::Pico->dbh($dbh);

    Note that "dbh()" method is not exported.

AUTHOR
    Yusuke Kawasaki http://www.kawa.net/

COPYRIGHT
    The following copyright notice applies to all the files provided in this
    distribution, including binary files, unless explicitly noted otherwise.

    Copyright 2012 Yusuke Kawasaki

LICENSE
    This library is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself.

SEE ALSO
    DBI executes SQL statements built by the module.

    SQL::Abstract::Query provides a list of other SQL generators as
    reference.

